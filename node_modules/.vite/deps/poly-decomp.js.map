{
  "version": 3,
  "sources": ["../../poly-decomp/src/index.js"],
  "sourcesContent": ["module.exports = {\n    decomp: polygonDecomp,\n    quickDecomp: polygonQuickDecomp,\n    isSimple: polygonIsSimple,\n    removeCollinearPoints: polygonRemoveCollinearPoints,\n    removeDuplicatePoints: polygonRemoveDuplicatePoints,\n    makeCCW: polygonMakeCCW\n};\n\n/**\n * Compute the intersection between two lines.\n * @static\n * @method lineInt\n * @param  {Array}  l1          Line vector 1\n * @param  {Array}  l2          Line vector 2\n * @param  {Number} precision   Precision to use when checking if the lines are parallel\n * @return {Array}              The intersection point.\n */\nfunction lineInt(l1,l2,precision){\n    precision = precision || 0;\n    var i = [0,0]; // point\n    var a1, b1, c1, a2, b2, c2, det; // scalars\n    a1 = l1[1][1] - l1[0][1];\n    b1 = l1[0][0] - l1[1][0];\n    c1 = a1 * l1[0][0] + b1 * l1[0][1];\n    a2 = l2[1][1] - l2[0][1];\n    b2 = l2[0][0] - l2[1][0];\n    c2 = a2 * l2[0][0] + b2 * l2[0][1];\n    det = a1 * b2 - a2*b1;\n    if (!scalar_eq(det, 0, precision)) { // lines are not parallel\n        i[0] = (b2 * c1 - b1 * c2) / det;\n        i[1] = (a1 * c2 - a2 * c1) / det;\n    }\n    return i;\n}\n\n/**\n * Checks if two line segments intersects.\n * @method segmentsIntersect\n * @param {Array} p1 The start vertex of the first line segment.\n * @param {Array} p2 The end vertex of the first line segment.\n * @param {Array} q1 The start vertex of the second line segment.\n * @param {Array} q2 The end vertex of the second line segment.\n * @return {Boolean} True if the two line segments intersect\n */\nfunction lineSegmentsIntersect(p1, p2, q1, q2){\n\tvar dx = p2[0] - p1[0];\n\tvar dy = p2[1] - p1[1];\n\tvar da = q2[0] - q1[0];\n\tvar db = q2[1] - q1[1];\n\n\t// segments are parallel\n\tif((da*dy - db*dx) === 0){\n\t\treturn false;\n\t}\n\n\tvar s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);\n\tvar t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);\n\n\treturn (s>=0 && s<=1 && t>=0 && t<=1);\n}\n\n/**\n * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.\n * @static\n * @method area\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @return {Number}\n */\nfunction triangleArea(a,b,c){\n    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1])));\n}\n\nfunction isLeft(a,b,c){\n    return triangleArea(a,b,c) > 0;\n}\n\nfunction isLeftOn(a,b,c) {\n    return triangleArea(a, b, c) >= 0;\n}\n\nfunction isRight(a,b,c) {\n    return triangleArea(a, b, c) < 0;\n}\n\nfunction isRightOn(a,b,c) {\n    return triangleArea(a, b, c) <= 0;\n}\n\nvar tmpPoint1 = [],\n    tmpPoint2 = [];\n\n/**\n * Check if three points are collinear\n * @method collinear\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.\n * @return {Boolean}\n */\nfunction collinear(a,b,c,thresholdAngle) {\n    if(!thresholdAngle){\n        return triangleArea(a, b, c) === 0;\n    } else {\n        var ab = tmpPoint1,\n            bc = tmpPoint2;\n\n        ab[0] = b[0]-a[0];\n        ab[1] = b[1]-a[1];\n        bc[0] = c[0]-b[0];\n        bc[1] = c[1]-b[1];\n\n        var dot = ab[0]*bc[0] + ab[1]*bc[1],\n            magA = Math.sqrt(ab[0]*ab[0] + ab[1]*ab[1]),\n            magB = Math.sqrt(bc[0]*bc[0] + bc[1]*bc[1]),\n            angle = Math.acos(dot/(magA*magB));\n        return angle < thresholdAngle;\n    }\n}\n\nfunction sqdist(a,b){\n    var dx = b[0] - a[0];\n    var dy = b[1] - a[1];\n    return dx * dx + dy * dy;\n}\n\n/**\n * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.\n * @method at\n * @param  {Number} i\n * @return {Array}\n */\nfunction polygonAt(polygon, i){\n    var s = polygon.length;\n    return polygon[i < 0 ? i % s + s : i % s];\n}\n\n/**\n * Clear the polygon data\n * @method clear\n * @return {Array}\n */\nfunction polygonClear(polygon){\n    polygon.length = 0;\n}\n\n/**\n * Append points \"from\" to \"to\"-1 from an other polygon \"poly\" onto this one.\n * @method append\n * @param {Polygon} poly The polygon to get points from.\n * @param {Number}  from The vertex index in \"poly\".\n * @param {Number}  to The end vertex index in \"poly\". Note that this vertex is NOT included when appending.\n * @return {Array}\n */\nfunction polygonAppend(polygon, poly, from, to){\n    for(var i=from; i<to; i++){\n        polygon.push(poly[i]);\n    }\n}\n\n/**\n * Make sure that the polygon vertices are ordered counter-clockwise.\n * @method makeCCW\n */\nfunction polygonMakeCCW(polygon){\n    var br = 0,\n        v = polygon;\n\n    // find bottom right point\n    for (var i = 1; i < polygon.length; ++i) {\n        if (v[i][1] < v[br][1] || (v[i][1] === v[br][1] && v[i][0] > v[br][0])) {\n            br = i;\n        }\n    }\n\n    // reverse poly if clockwise\n    if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {\n        polygonReverse(polygon);\n        return true;\n    } else {\n        return false;\n    }\n}\n\n/**\n * Reverse the vertices in the polygon\n * @method reverse\n */\nfunction polygonReverse(polygon){\n    var tmp = [];\n    var N = polygon.length;\n    for(var i=0; i!==N; i++){\n        tmp.push(polygon.pop());\n    }\n    for(var i=0; i!==N; i++){\n\t\tpolygon[i] = tmp[i];\n    }\n}\n\n/**\n * Check if a point in the polygon is a reflex point\n * @method isReflex\n * @param  {Number}  i\n * @return {Boolean}\n */\nfunction polygonIsReflex(polygon, i){\n    return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));\n}\n\nvar tmpLine1=[],\n    tmpLine2=[];\n\n/**\n * Check if two vertices in the polygon can see each other\n * @method canSee\n * @param  {Number} a Vertex index 1\n * @param  {Number} b Vertex index 2\n * @return {Boolean}\n */\nfunction polygonCanSee(polygon, a,b) {\n    var p, dist, l1=tmpLine1, l2=tmpLine2;\n\n    if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {\n        return false;\n    }\n    dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));\n    for (var i = 0; i !== polygon.length; ++i) { // for each edge\n        if ((i + 1) % polygon.length === a || i === a){ // ignore incident edges\n            continue;\n        }\n        if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) { // if diag intersects an edge\n            l1[0] = polygonAt(polygon, a);\n            l1[1] = polygonAt(polygon, b);\n            l2[0] = polygonAt(polygon, i);\n            l2[1] = polygonAt(polygon, i + 1);\n            p = lineInt(l1,l2);\n            if (sqdist(polygonAt(polygon, a), p) < dist) { // if edge is blocking visibility to b\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n/**\n * Check if two vertices in the polygon can see each other\n * @method canSee2\n * @param  {Number} a Vertex index 1\n * @param  {Number} b Vertex index 2\n * @return {Boolean}\n */\nfunction polygonCanSee2(polygon, a,b) {\n    // for each edge\n    for (var i = 0; i !== polygon.length; ++i) {\n        // ignore incident edges\n        if (i === a || i === b || (i + 1) % polygon.length === a || (i + 1) % polygon.length === b){\n            continue;\n        }\n        if( lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i), polygonAt(polygon, i+1)) ){\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * Copy the polygon from vertex i to vertex j.\n * @method copy\n * @param  {Number} i\n * @param  {Number} j\n * @param  {Polygon} [targetPoly]   Optional target polygon to save in.\n * @return {Polygon}                The resulting copy.\n */\nfunction polygonCopy(polygon, i,j,targetPoly){\n    var p = targetPoly || [];\n    polygonClear(p);\n    if (i < j) {\n        // Insert all vertices from i to j\n        for(var k=i; k<=j; k++){\n            p.push(polygon[k]);\n        }\n\n    } else {\n\n        // Insert vertices 0 to j\n        for(var k=0; k<=j; k++){\n            p.push(polygon[k]);\n        }\n\n        // Insert vertices i to end\n        for(var k=i; k<polygon.length; k++){\n            p.push(polygon[k]);\n        }\n    }\n\n    return p;\n}\n\n/**\n * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.\n * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.\n * @method getCutEdges\n * @return {Array}\n */\nfunction polygonGetCutEdges(polygon) {\n    var min=[], tmp1=[], tmp2=[], tmpPoly = [];\n    var nDiags = Number.MAX_VALUE;\n\n    for (var i = 0; i < polygon.length; ++i) {\n        if (polygonIsReflex(polygon, i)) {\n            for (var j = 0; j < polygon.length; ++j) {\n                if (polygonCanSee(polygon, i, j)) {\n                    tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));\n                    tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));\n\n                    for(var k=0; k<tmp2.length; k++){\n                        tmp1.push(tmp2[k]);\n                    }\n\n                    if (tmp1.length < nDiags) {\n                        min = tmp1;\n                        nDiags = tmp1.length;\n                        min.push([polygonAt(polygon, i), polygonAt(polygon, j)]);\n                    }\n                }\n            }\n        }\n    }\n\n    return min;\n}\n\n/**\n * Decomposes the polygon into one or more convex sub-Polygons.\n * @method decomp\n * @return {Array} An array or Polygon objects.\n */\nfunction polygonDecomp(polygon){\n    var edges = polygonGetCutEdges(polygon);\n    if(edges.length > 0){\n        return polygonSlice(polygon, edges);\n    } else {\n        return [polygon];\n    }\n}\n\n/**\n * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.\n * @method slice\n * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()\n * @return {Array}\n */\nfunction polygonSlice(polygon, cutEdges){\n    if(cutEdges.length === 0){\n\t\treturn [polygon];\n    }\n    if(cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length===2 && cutEdges[0][0] instanceof Array){\n\n        var polys = [polygon];\n\n        for(var i=0; i<cutEdges.length; i++){\n            var cutEdge = cutEdges[i];\n            // Cut all polys\n            for(var j=0; j<polys.length; j++){\n                var poly = polys[j];\n                var result = polygonSlice(poly, cutEdge);\n                if(result){\n                    // Found poly! Cut and quit\n                    polys.splice(j,1);\n                    polys.push(result[0],result[1]);\n                    break;\n                }\n            }\n        }\n\n        return polys;\n    } else {\n\n        // Was given one edge\n        var cutEdge = cutEdges;\n        var i = polygon.indexOf(cutEdge[0]);\n        var j = polygon.indexOf(cutEdge[1]);\n\n        if(i !== -1 && j !== -1){\n            return [polygonCopy(polygon, i,j),\n                    polygonCopy(polygon, j,i)];\n        } else {\n            return false;\n        }\n    }\n}\n\n/**\n * Checks that the line segments of this polygon do not intersect each other.\n * @method isSimple\n * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]\n * @return {Boolean}\n * @todo Should it check all segments with all others?\n */\nfunction polygonIsSimple(polygon){\n    var path = polygon, i;\n    // Check\n    for(i=0; i<path.length-1; i++){\n        for(var j=0; j<i-1; j++){\n            if(lineSegmentsIntersect(path[i], path[i+1], path[j], path[j+1] )){\n                return false;\n            }\n        }\n    }\n\n    // Check the segment between the last and the first point to all others\n    for(i=1; i<path.length-2; i++){\n        if(lineSegmentsIntersect(path[0], path[path.length-1], path[i], path[i+1] )){\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction getIntersectionPoint(p1, p2, q1, q2, delta){\n\tdelta = delta || 0;\n\tvar a1 = p2[1] - p1[1];\n\tvar b1 = p1[0] - p2[0];\n\tvar c1 = (a1 * p1[0]) + (b1 * p1[1]);\n\tvar a2 = q2[1] - q1[1];\n\tvar b2 = q1[0] - q2[0];\n\tvar c2 = (a2 * q1[0]) + (b2 * q1[1]);\n\tvar det = (a1 * b2) - (a2 * b1);\n\n\tif(!scalar_eq(det,0,delta)){\n\t\treturn [((b2 * c1) - (b1 * c2)) / det, ((a1 * c2) - (a2 * c1)) / det];\n\t} else {\n\t\treturn [0,0];\n    }\n}\n\n/**\n * Quickly decompose the Polygon into convex sub-polygons.\n * @method quickDecomp\n * @param  {Array} result\n * @param  {Array} [reflexVertices]\n * @param  {Array} [steinerPoints]\n * @param  {Number} [delta]\n * @param  {Number} [maxlevel]\n * @param  {Number} [level]\n * @return {Array}\n */\nfunction polygonQuickDecomp(polygon, result,reflexVertices,steinerPoints,delta,maxlevel,level){\n    maxlevel = maxlevel || 100;\n    level = level || 0;\n    delta = delta || 25;\n    result = typeof(result)!==\"undefined\" ? result : [];\n    reflexVertices = reflexVertices || [];\n    steinerPoints = steinerPoints || [];\n\n    var upperInt=[0,0], lowerInt=[0,0], p=[0,0]; // Points\n    var upperDist=0, lowerDist=0, d=0, closestDist=0; // scalars\n    var upperIndex=0, lowerIndex=0, closestIndex=0; // Integers\n    var lowerPoly=[], upperPoly=[]; // polygons\n    var poly = polygon,\n        v = polygon;\n\n    if(v.length < 3){\n\t\treturn result;\n    }\n\n    level++;\n    if(level > maxlevel){\n        console.warn(\"quickDecomp: max level (\"+maxlevel+\") reached.\");\n        return result;\n    }\n\n    for (var i = 0; i < polygon.length; ++i) {\n        if (polygonIsReflex(poly, i)) {\n            reflexVertices.push(poly[i]);\n            upperDist = lowerDist = Number.MAX_VALUE;\n\n\n            for (var j = 0; j < polygon.length; ++j) {\n                if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) { // if line intersects with an edge\n                    p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1)); // find the point of intersection\n                    if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) { // make sure it's inside the poly\n                        d = sqdist(poly[i], p);\n                        if (d < lowerDist) { // keep only the closest intersection\n                            lowerDist = d;\n                            lowerInt = p;\n                            lowerIndex = j;\n                        }\n                    }\n                }\n                if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\n                    p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));\n                    if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {\n                        d = sqdist(poly[i], p);\n                        if (d < upperDist) {\n                            upperDist = d;\n                            upperInt = p;\n                            upperIndex = j;\n                        }\n                    }\n                }\n            }\n\n            // if there are no vertices to connect to, choose a point in the middle\n            if (lowerIndex === (upperIndex + 1) % polygon.length) {\n                //console.log(\"Case 1: Vertex(\"+i+\"), lowerIndex(\"+lowerIndex+\"), upperIndex(\"+upperIndex+\"), poly.size(\"+polygon.length+\")\");\n                p[0] = (lowerInt[0] + upperInt[0]) / 2;\n                p[1] = (lowerInt[1] + upperInt[1]) / 2;\n                steinerPoints.push(p);\n\n                if (i < upperIndex) {\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);\n                    polygonAppend(lowerPoly, poly, i, upperIndex+1);\n                    lowerPoly.push(p);\n                    upperPoly.push(p);\n                    if (lowerIndex !== 0){\n                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());\n                        polygonAppend(upperPoly, poly,lowerIndex,poly.length);\n                    }\n                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);\n                    polygonAppend(upperPoly, poly,0,i+1);\n                } else {\n                    if (i !== 0){\n                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());\n                        polygonAppend(lowerPoly, poly,i,poly.length);\n                    }\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);\n                    polygonAppend(lowerPoly, poly,0,upperIndex+1);\n                    lowerPoly.push(p);\n                    upperPoly.push(p);\n                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);\n                    polygonAppend(upperPoly, poly,lowerIndex,i+1);\n                }\n            } else {\n                // connect to the closest point within the triangle\n                //console.log(\"Case 2: Vertex(\"+i+\"), closestIndex(\"+closestIndex+\"), poly.size(\"+polygon.length+\")\\n\");\n\n                if (lowerIndex > upperIndex) {\n                    upperIndex += polygon.length;\n                }\n                closestDist = Number.MAX_VALUE;\n\n                if(upperIndex < lowerIndex){\n                    return result;\n                }\n\n                for (var j = lowerIndex; j <= upperIndex; ++j) {\n                    if (\n                        isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) &&\n                        isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))\n                    ) {\n                        d = sqdist(polygonAt(poly, i), polygonAt(poly, j));\n                        if (d < closestDist && polygonCanSee2(poly, i, j)) {\n                            closestDist = d;\n                            closestIndex = j % polygon.length;\n                        }\n                    }\n                }\n\n                if (i < closestIndex) {\n                    polygonAppend(lowerPoly, poly,i,closestIndex+1);\n                    if (closestIndex !== 0){\n                        polygonAppend(upperPoly, poly,closestIndex,v.length);\n                    }\n                    polygonAppend(upperPoly, poly,0,i+1);\n                } else {\n                    if (i !== 0){\n                        polygonAppend(lowerPoly, poly,i,v.length);\n                    }\n                    polygonAppend(lowerPoly, poly,0,closestIndex+1);\n                    polygonAppend(upperPoly, poly,closestIndex,i+1);\n                }\n            }\n\n            // solve smallest poly first\n            if (lowerPoly.length < upperPoly.length) {\n                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n            } else {\n                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n            }\n\n            return result;\n        }\n    }\n    result.push(polygon);\n\n    return result;\n}\n\n/**\n * Remove collinear points in the polygon.\n * @method removeCollinearPoints\n * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.\n * @return {Number}           The number of points removed\n */\nfunction polygonRemoveCollinearPoints(polygon, precision){\n    var num = 0;\n    for(var i=polygon.length-1; polygon.length>3 && i>=0; --i){\n        if(collinear(polygonAt(polygon, i-1),polygonAt(polygon, i),polygonAt(polygon, i+1),precision)){\n            // Remove the middle point\n            polygon.splice(i%polygon.length,1);\n            num++;\n        }\n    }\n    return num;\n}\n\n/**\n * Remove duplicate points in the polygon.\n * @method removeDuplicatePoints\n * @param  {Number} [precision] The threshold to use when determining whether two points are the same. Use zero for best precision.\n */\nfunction polygonRemoveDuplicatePoints(polygon, precision){\n    for(var i=polygon.length-1; i>=1; --i){\n        var pi = polygon[i];\n        for(var j=i-1; j>=0; --j){\n            if(points_eq(pi, polygon[j], precision)){\n                polygon.splice(i,1);\n                continue;\n            }\n        }\n    }\n}\n\n/**\n * Check if two scalars are equal\n * @static\n * @method eq\n * @param  {Number} a\n * @param  {Number} b\n * @param  {Number} [precision]\n * @return {Boolean}\n */\nfunction scalar_eq(a,b,precision){\n    precision = precision || 0;\n    return Math.abs(a-b) <= precision;\n}\n\n/**\n * Check if two points are equal\n * @static\n * @method points_eq\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Number} [precision]\n * @return {Boolean}\n */\nfunction points_eq(a,b,precision){\n    return scalar_eq(a[0],b[0],precision) && scalar_eq(a[1],b[1],precision);\n}\n"],
  "mappings": "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",
  "names": []
}
